using System;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Windows.Forms;

namespace LexicalAnalyzerV1
{
    public partial class Form1 : Form
    {
        //Symbol Table 2D List
        List<List<string>> Symboltable = new List<List<string>>();

        ArrayList LineNumber;
        ArrayList Variables;
        ArrayList KeyWords;
        ArrayList Constants;

        ArrayList finalArray;
        ArrayList tempArray;

        Regex variable_Reg;
        Regex constants_Reg;
        Regex operators_Reg;
        Regex special_Reg;

        int lexemes_per_line;
        int ST_index;

        public Form1()
        {
            InitializeComponent();

            LineNumber = new ArrayList();
            Variables = new ArrayList();
            KeyWords = new ArrayList();
            Constants = new ArrayList();

            finalArray = new ArrayList();
            tempArray = new ArrayList();

            // Regex
            variable_Reg = new Regex(@"^[A-Za-z_][A-Za-z0-9_]*$");
            constants_Reg = new Regex(@"^[0-9]+([.][0-9]+)?$");
            operators_Reg = new Regex(@"^[-+*/=<>]$");
            special_Reg = new Regex(@"^[.,'\[\]{}();:?]$");

            Symboltable.Clear();

            Output.Text = "";
            ST.Text = "";
        }

        private void btn_Input_Click(object sender, EventArgs e)
        {
            string userInput = tfInput.Text;

            List<string> keywordList = new List<string>()
            {
                "int", "float", "while", "main", "if", "else", "new"
            };

            String[,] SymbolTable = new String[50, 6];

            int row = 1;
            int count = 1;
            int line_num = 0;

            finalArray.Clear();
            tempArray.Clear();
            tfTokens.Clear();
            symbolTable.Clear();

            char[] charinput = userInput.ToCharArray();

            // FIRST PASS — SPLIT LINES
            for (int i = 0; i < charinput.Length; i++)
            {
                if (charinput[i] != '\n')
                {
                    tempArray.Add(charinput[i]);
                }
                else
                {
                    finalArray.Add(new string((char[])tempArray.ToArray(typeof(char))));
                    tempArray.Clear();
                }
            }

            if (tempArray.Count != 0)
            {
                finalArray.Add(new string((char[])tempArray.ToArray(typeof(char))));
                tempArray.Clear();
            }

            // SECOND PASS — TOKENIZATION
            ArrayList finalArrayc = new ArrayList();

            for (int i = 0; i < finalArray.Count; i++)
            {
                string line = finalArray[i].ToString();
                line_num++;

                finalArrayc.Clear();
                tempArray.Clear();

                char[] arr = line.ToCharArray();

                for (int j = 0; j < arr.Length; j++)
                {
                    string ch = arr[j].ToString();

                    Match isVar = variable_Reg.Match(ch);
                    Match isConst = constants_Reg.Match(ch);
                    Match isOp = operators_Reg.Match(ch);
                    Match isSpec = special_Reg.Match(ch);

                    if (isVar.Success || isConst.Success)
                    {
                        tempArray.Add(ch);
                    }
                    else if (ch == " ")
                    {
                        if (tempArray.Count != 0)
                        {
                            finalArrayc.Add(new string((char[])tempArray.ToArray(typeof(char))));
                            tempArray.Clear();
                        }
                    }
                    else if (isOp.Success || isSpec.Success)
                    {
                        if (tempArray.Count != 0)
                        {
                            finalArrayc.Add(new string((char[])tempArray.ToArray(typeof(char))));
                            tempArray.Clear();
                        }
                        finalArrayc.Add(ch);
                    }
                }

                if (tempArray.Count != 0)
                {
                    finalArrayc.Add(new string((char[])tempArray.ToArray(typeof(char))));
                    tempArray.Clear();
                }

                // THIRD PASS — GENERATE TOKENS
                for (int x = 0; x < finalArrayc.Count; x++)
                {
                    string lex = finalArrayc[x].ToString();

                    Match op = operators_Reg.Match(lex);
                    Match dig = constants_Reg.Match(lex);
                    Match var = variable_Reg.Match(lex);
                    Match punct = special_Reg.Match(lex);

                    if (op.Success)
                    {
                        tfTokens.AppendText("<op, " + lex + "> ");
                    }
                    else if (dig.Success)
                    {
                        tfTokens.AppendText("<digit, " + lex + "> ");
                    }
                    else if (punct.Success)
                    {
                        tfTokens.AppendText("<punc, " + lex + "> ");
                    }
                    else if (var.Success)
                    {
                        if (!keywordList.Contains(lex))
                        {
                            // Variable Token
                            tfTokens.AppendText("<var" + count + ", " + row + "> ");

                            SymbolTable[row, 1] = row.ToString();
                            SymbolTable[row, 2] = lex;
                            SymbolTable[row, 3] = "unknown";
                            SymbolTable[row, 4] = "null";
                            SymbolTable[row, 5] = line_num.ToString();

                            symbolTable.AppendText(
                                SymbolTable[row, 1] + "\t" +
                                SymbolTable[row, 2] + "\t" +
                                SymbolTable[row, 3] + "\t" +
                                SymbolTable[row, 4] + "\t" +
                                SymbolTable[row, 5] + "\n"
                            );

                            row++;
                            count++;
                        }
                        else
                        {
                            // Keyword token
                            tfTokens.AppendText("<keyword, " + lex + "> ");
                        }
                    }
                }

                tfTokens.AppendText("\n");
            }
        }
    }
}
